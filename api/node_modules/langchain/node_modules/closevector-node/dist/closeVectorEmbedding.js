"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloseVectorEmbeddingsNode = void 0;
const lib_1 = require("./lib");
const axios_1 = __importDefault(require("axios"));
class CloseVectorEmbeddingsNode {
    constructor(fields) {
        this.batchSize = 512;
        this.stripNewLines = true;
        this.batchSize = fields.batchSize || this.batchSize;
        this.stripNewLines = fields.stripNewLines || this.stripNewLines;
        this.timeout = fields.timeout;
        this.config = {
            key: fields.key,
            secret: fields.secret,
        };
    }
    embedDocuments(texts) {
        return __awaiter(this, void 0, void 0, function* () {
            const subPrompts = (0, lib_1.chunkArray)(this.stripNewLines ? texts.map(t => t.replace(/\n/g, ' ')) : texts, this.batchSize);
            const embeddings = [];
            for (let i = 0; i < subPrompts.length; i += 1) {
                const input = subPrompts[i];
                const { data } = yield this.embeddingWithRetry(input);
                for (let j = 0; j < input.length; j += 1) {
                    embeddings.push(data[j].embedding);
                }
            }
            return embeddings;
        });
    }
    embedQuery(text) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.embeddingWithRetry(this.stripNewLines ? [text.replace(/\n/g, ' ')] : [text]);
            return data[0].embedding;
        });
    }
    embeddingWithRetry(textList) {
        return __awaiter(this, void 0, void 0, function* () {
            let accessKey = this.config.key;
            let secret = this.config.secret;
            const axiosInstance = axios_1.default.create({
                baseURL: lib_1.END_POINT,
                headers: {
                    Authorization: `Bearer ${accessKey}:${yield (0, lib_1.encryptToken)({ accessKey }, secret)}`,
                },
            });
            const createEmbeddings = (textList) => __awaiter(this, void 0, void 0, function* () {
                const options = {
                    method: 'POST',
                    url: '/embeddings',
                    data: JSON.stringify(textList),
                };
                const response = yield axiosInstance.request(options);
                return response.data;
            });
            return createEmbeddings(textList);
        });
    }
}
exports.CloseVectorEmbeddingsNode = CloseVectorEmbeddingsNode;
//# sourceMappingURL=closeVectorEmbedding.js.map