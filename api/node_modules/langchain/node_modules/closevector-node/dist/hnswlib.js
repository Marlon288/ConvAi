"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HNSWLib = exports.CloseVectorHNSWNode = exports.SynchronousInMemoryDocstore = exports.CloseVectorSaveableVectorStore = void 0;
const closevector_common_1 = require("closevector-common");
var closevector_common_2 = require("closevector-common");
Object.defineProperty(exports, "CloseVectorSaveableVectorStore", { enumerable: true, get: function () { return closevector_common_2.CloseVectorSaveableVectorStore; } });
Object.defineProperty(exports, "SynchronousInMemoryDocstore", { enumerable: true, get: function () { return closevector_common_2.SynchronousInMemoryDocstore; } });
const io_1 = require("./io");
class CloseVectorHNSWNode extends closevector_common_1.CloseVectorSaveableVectorStore {
    _vectorstoreType() {
        return 'hnswlib';
    }
    constructor(embeddings, args) {
        var _a;
        super(embeddings, args.credentials);
        this._index = args.index;
        this.args = args;
        this.embeddings = embeddings;
        this.docstore = (_a = args === null || args === void 0 ? void 0 : args.docstore) !== null && _a !== void 0 ? _a : new closevector_common_1.SynchronousInMemoryDocstore();
    }
    addDocuments(documents) {
        return __awaiter(this, void 0, void 0, function* () {
            const texts = documents.map(({ pageContent }) => pageContent);
            return this.addVectors(yield this.embeddings.embedDocuments(texts), documents);
        });
    }
    static getHierarchicalNSW(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const { HierarchicalNSW } = yield CloseVectorHNSWNode.imports();
            if (!args.space) {
                throw new Error('closevector-hnswlib-node requires a space argument');
            }
            if (args.numDimensions === undefined) {
                throw new Error('closevector-hnswlib-node requires a numDimensions argument');
            }
            return new HierarchicalNSW(args.space, args.numDimensions);
        });
    }
    initIndex(vectors) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._index) {
                if (this.args.numDimensions === undefined) {
                    this.args.numDimensions = vectors[0].length;
                }
                this.index = yield CloseVectorHNSWNode.getHierarchicalNSW(this.args);
            }
            if (!this.index.getCurrentCount()) {
                this.index.initIndex(vectors.length, 48, 200, 100);
                this.index.setEf(32);
            }
        });
    }
    get index() {
        if (!this._index) {
            throw new Error('Vector store not initialised yet. Try calling `addTexts` first.');
        }
        return this._index;
    }
    set index(index) {
        this._index = index;
    }
    get uuid() {
        return this._uuid;
    }
    set uuid(uuid) {
        this._uuid = uuid;
    }
    addVectors(vectors, documents) {
        return __awaiter(this, void 0, void 0, function* () {
            if (vectors.length === 0) {
                return;
            }
            yield this.initIndex(vectors);
            // TODO here we could optionally normalise the vectors to unit length
            // so that dot product is equivalent to cosine similarity, like this
            // https://github.com/nmslib/hnswlib/issues/384#issuecomment-1155737730
            // While we only support OpenAI embeddings this isn't necessary
            if (vectors.length !== documents.length) {
                throw new Error(`Vectors and metadatas must have the same length`);
            }
            if (vectors[0].length !== this.args.numDimensions) {
                throw new Error(`Vectors must have the same length as the number of dimensions (${this.args.numDimensions})`);
            }
            const capacity = this.index.getMaxElements();
            const needed = this.index.getCurrentCount() + vectors.length;
            if (needed > capacity) {
                this.index.resizeIndex(needed);
            }
            const docstoreSize = this.index.getCurrentCount();
            const toSave = {};
            for (let i = 0; i < vectors.length; i += 1) {
                this.index.addPoint(vectors[i], docstoreSize + i);
                toSave[docstoreSize + i] = documents[i];
            }
            this.docstore.add(toSave);
        });
    }
    similaritySearchVectorWithScore(query, k, filter) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.args.numDimensions && !this._index) {
                yield this.initIndex([[]]);
            }
            if (query.length !== this.args.numDimensions) {
                throw new Error(`Query vector must have the same length as the number of dimensions (${this.args.numDimensions})`);
            }
            if (k > this.index.getCurrentCount()) {
                const total = this.index.getCurrentCount();
                console.warn(`k (${k}) is greater than the number of elements in the index (${total}), setting k to ${total}`);
                // eslint-disable-next-line no-param-reassign
                k = total;
            }
            const filterFunction = (label) => {
                if (!filter) {
                    return true;
                }
                const document = this.docstore.search(String(label));
                // eslint-disable-next-line no-instanceof/no-instanceof
                if (typeof document !== 'string') {
                    const resp = filter(document);
                    return resp;
                }
                return false;
            };
            const result = this.index.searchKnn(query, k, filter ? filterFunction : undefined);
            return result.neighbors.map((docIndex, resultIndex) => [this.docstore.search(String(docIndex)), result.distances[resultIndex]]);
        });
    }
    delete(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const fs = yield Promise.resolve().then(() => __importStar(require('node:fs/promises')));
            const path = yield Promise.resolve().then(() => __importStar(require('node:path')));
            try {
                yield fs.access(path.join(params.directory, 'hnswlib.index'));
            }
            catch (err) {
                throw new Error(`Directory ${params.directory} does not contain a hnswlib.index file.`);
            }
            yield Promise.all([
                yield fs.rm(path.join(params.directory, 'hnswlib.index'), {
                    force: true,
                }),
                yield fs.rm(path.join(params.directory, 'docstore.json'), {
                    force: true,
                }),
                yield fs.rm(path.join(params.directory, 'args.json'), { force: true }),
            ]);
        });
    }
    saveToCloud(options) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const _credentials = (_a = options === null || options === void 0 ? void 0 : options.credentials) !== null && _a !== void 0 ? _a : this.credentials;
            if (!_credentials) {
                throw new Error('No credentials set');
            }
            const _options = {
                uuid: (_b = options === null || options === void 0 ? void 0 : options.uuid) !== null && _b !== void 0 ? _b : this.uuid,
                // default as date as string
                description: (_c = options === null || options === void 0 ? void 0 : options.description) !== null && _c !== void 0 ? _c : new Date().toISOString(),
                accessKey: _credentials.key,
                secret: _credentials.secret
            };
            const uuid = yield (0, io_1.upsertIndex)(this, Object.assign(Object.assign({}, _options), { onProgress(progress) {
                    if (options === null || options === void 0 ? void 0 : options.onProgress) {
                        const total = progress.total;
                        const loaded = progress.loaded;
                        options.onProgress({ loaded, total });
                    }
                } }));
            this.uuid = uuid;
            return uuid;
        });
    }
    save(directory) {
        return __awaiter(this, void 0, void 0, function* () {
            const fs = yield Promise.resolve().then(() => __importStar(require('node:fs/promises')));
            const path = yield Promise.resolve().then(() => __importStar(require('node:path')));
            yield fs.mkdir(directory, { recursive: true });
            yield Promise.all([
                this.index.writeIndex(path.join(directory, 'hnswlib.index')),
                yield fs.writeFile(path.join(directory, 'args.json'), JSON.stringify(this.args)),
                yield fs.writeFile(path.join(directory, 'docstore.json'), JSON.stringify(Array.from(this.docstore._docs.entries()))),
            ]);
        });
    }
    static loadFromCloud(options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { key, secret } = (_a = options.credentials) !== null && _a !== void 0 ? _a : {};
            if (!key || !secret) {
                throw new Error('No accessKey or secret set');
            }
            const instance = yield (0, io_1.getIndex)({
                uuid: options.uuid,
                accessKey: options.credentials.key,
                secret: options.credentials.secret,
                embeddings: options.embeddings,
                onProgress(progress) {
                    if (options.onProgress) {
                        const total = progress.total;
                        const loaded = progress.loaded;
                        options.onProgress({ loaded, total });
                    }
                },
            });
            instance.credentials = options.credentials;
            instance.uuid = options.uuid;
            return instance;
        });
    }
    static load(directory, embeddings) {
        return __awaiter(this, void 0, void 0, function* () {
            const fs = yield Promise.resolve().then(() => __importStar(require('node:fs/promises')));
            const path = yield Promise.resolve().then(() => __importStar(require('node:path')));
            const args = JSON.parse(yield fs.readFile(path.join(directory, 'args.json'), 'utf8'));
            const index = yield CloseVectorHNSWNode.getHierarchicalNSW(args);
            const [docstoreFiles] = yield Promise.all([
                fs.readFile(path.join(directory, 'docstore.json'), 'utf8').then(JSON.parse),
                index.readIndex(path.join(directory, 'hnswlib.index')),
            ]);
            args.docstore = new closevector_common_1.SynchronousInMemoryDocstore(new Map(docstoreFiles));
            args.index = index;
            return new CloseVectorHNSWNode(embeddings, args);
        });
    }
    static fromTexts(texts, metadatas, embeddings, dbConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const docs = [];
            for (let i = 0; i < texts.length; i += 1) {
                const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;
                const newDoc = {
                    pageContent: texts[i],
                    metadata,
                };
                docs.push(newDoc);
            }
            return CloseVectorHNSWNode.fromDocuments(docs, embeddings, dbConfig);
        });
    }
    static fromDocuments(docs, embeddings, dbConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = {
                docstore: dbConfig === null || dbConfig === void 0 ? void 0 : dbConfig.docstore,
                space: 'cosine',
            };
            const instance = new this(embeddings, args);
            yield instance.addDocuments(docs);
            return instance;
        });
    }
    static imports() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { default: { HierarchicalNSW }, } = yield Promise.resolve().then(() => __importStar(require('closevector-hnswlib-node')));
                return { HierarchicalNSW };
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }
            catch (err) {
                throw new Error(`Could not import closevector-hnswlib-node. Please install closevector-hnswlib-node as a dependency with, e.g. \`npm install -S closevector-hnswlib-node\`.\n\nError: ${err === null || err === void 0 ? void 0 : err.message}`);
            }
        });
    }
}
exports.CloseVectorHNSWNode = CloseVectorHNSWNode;
exports.HNSWLib = CloseVectorHNSWNode;
//# sourceMappingURL=hnswlib.js.map